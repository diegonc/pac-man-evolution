\documentclass{article}

\usepackage[spanish]{babel}
\usepackage[latin1]{inputenc}

\begin{document}

\section{Optimizaciones.}

\subsection{Inversión de ciclos.}

El método consiste en invertir los ciclos exteriores del método básico para lograr que la matriz de resultados se recorra por columnas, aprovechando mejor la memoria cache.

\subsection{Multiplicación por columnas.}

Este método realiza la multiplicación de matrices en forma incremental, efectuando todas las operaciones posibles con los elementos disponibles de una de las matrices y sumando los resultados parciales en la matriz resultado.

Utilizando las propiedades de las matrices se consiguen las siguientes equivalencias que proporcionanan fundamento matemático al método. Por simplicidad, se utilizan matrices de 2x2.

$$
  \left[
	\begin{array}{cc}
		a_{11} & a_{12} \\
		a_{21} & a_{22}
	\end{array}
   \right]
   \left[
	\begin{array}{cc}
		b_{11} & b_{12} \\
		b_{21} & b_{22}
	\end{array}
   \right]
   =
   \left[
	\begin{array}{cc}
		c_{11} & c_{12} \\
		c_{21} & c_{22}
	\end{array}
   \right]
$$

El producto del miembro izquierdo se puede escribir como
$$
   \left(
	\left[
	\begin{array}{cc}
		a_{11} & 0 \\
		a_{21} & 0
	\end{array}
	\right]
        +
	\left[
	\begin{array}{cc}
		0 & a_{12} \\
		0 & a_{22}
	\end{array}
	\right]
   \right)
   \left(
   	\left[
	\begin{array}{cc}
		b_{11} & 0 \\
		b_{21} & 0
	\end{array}
	\right]
        +
	\left[
	\begin{array}{cc}
		0 & b_{12} \\
		0 & b_{22}
	\end{array}
	\right]
   \right)
$$

Y expandiendo los paréntesis resulta

$$
	\left[
	\begin{array}{cc}
		a_{11} & 0 \\
		a_{21} & 0
	\end{array}
	\right]
	\left[
	\begin{array}{cc}
		b_{11} & 0 \\
		b_{21} & 0
	\end{array}
	\right]
        +
	\left[
	\begin{array}{cc}
		0 & a_{12} \\
		0 & a_{22}
	\end{array}
	\right]
	\left[
	\begin{array}{cc}
		b_{11} & 0 \\
		b_{21} & 0
	\end{array}
	\right]
	+
	\left[
	\begin{array}{cc}
		a_{11} & 0 \\
		a_{21} & 0
	\end{array}
	\right]
	\left[
	\begin{array}{cc}
		0 & b_{12} \\
		0 & b_{22}
	\end{array}
	\right]
        +
	\left[
	\begin{array}{cc}
		0 & a_{12} \\
		0 & a_{22}
	\end{array}
	\right]
	\left[
	\begin{array}{cc}
		0 & b_{12} \\
		0 & b_{22}
	\end{array}
	\right]
$$

Así, la matriz producto se puede descomponer en la siguiente suma
$$
	\left[
	\begin{array}{cc}
		a_{11} b_{11} & 0 \\
		a_{21} b_{11} & 0
	\end{array}
	\right]
        +
	\left[
	\begin{array}{cc}
		a_{12} b_{21} & 0 \\
		a_{22} b_{21} & 0
	\end{array}
	\right]
	+
	\left[
	\begin{array}{cc}
		0 & a_{11} b_{12} \\
		0 & a_{21} b_{12}
	\end{array}
	\right]
        +
	\left[
	\begin{array}{cc}
		0 & a_{12} b_{22} \\
		0 & a_{22} b_{22}
	\end{array}
	\right]
$$

Como se puede apreciar, las tres matrices se acceden por columnas. Esto resulta en una mejor utilización de la memoria cache.

Sin embargo, para que funcione correctamente, se requiere que la matriz donde se almacena el resultado haya sido inicializada, ya sea previamente en 0 o con los primeros valores calculados de cada elemento.

\subsection{Multiplicación por bloques}

Generalizando el método anterior, es posible dividir la matriz en bloques de tamaño arbitrario y, procediendo de la misma forma, se obtiene una suma de matrices que  permiten calcular la multiplicación progresivamente, empleando un conjunto de datos reducido.

\subsection{Básico con trasposición.}

Al igual que en el método anterior, la trasposición de la primera matriz del producto permite que posiciones contiguas de memoria sean accedidas para las tres matrices, optimizando el uso de memoria cache.

Sin embargo, el desempeño de este método se ve impactado por la penalidad de calcular la matriz traspuesta, que requiere movimientos de grandes cantidades de datos.

\end{document}
